import tkinter as tk
from tkinter import ttk, messagebox, filedialog, simpledialog
import tempfile
import os
import webbrowser
from pathlib import Path
import threading
import json
import time
from openai import OpenAI

# Config file to store API key
CONFIG_FILE = "webide_config.json"

def load_config():
    """Load configuration from file"""
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    return {}

def save_config(config):
    """Save configuration to file"""
    try:
        with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
            json.dump(config, f, indent=2)
    except:
        pass

class ProgressDialog:
    """Modern progress dialog with animated progress bar"""
    def __init__(self, parent, title="Processing"):
        self.window = tk.Toplevel(parent)
        self.window.title(title)
        self.window.geometry("450x200")
        self.window.resizable(False, False)
        
        # Modern dark theme colors
        bg_color = "#2d2d30"
        fg_color = "#d4d4d4"
        accent = "#007acc"
        
        self.window.configure(bg=bg_color)
        self.window.transient(parent)
        self.window.grab_set()
        
        # Center the window
        self.window.update_idletasks()
        x = (self.window.winfo_screenwidth() // 2) - (450 // 2)
        y = (self.window.winfo_screenheight() // 2) - (200 // 2)
        self.window.geometry(f"+{x}+{y}")
        
        # Icon and title
        header_frame = tk.Frame(self.window, bg=bg_color)
        header_frame.pack(pady=(30, 20))
        
        icon_label = tk.Label(header_frame, text="ü§ñ", 
                            font=("Segoe UI", 32),
                            bg=bg_color, fg=fg_color)
        icon_label.pack()
        
        title_label = tk.Label(header_frame, text="AI is thinking...",
                             font=("Segoe UI", 12, "bold"),
                             bg=bg_color, fg=fg_color)
        title_label.pack(pady=(10, 0))
        
        # Status text
        self.status_label = tk.Label(self.window, 
                                    text="Preparing your request...",
                                    font=("Segoe UI", 9),
                                    bg=bg_color, fg="#858585")
        self.status_label.pack(pady=(0, 15))
        
        # Progress bar container
        progress_container = tk.Frame(self.window, bg=bg_color)
        progress_container.pack(fill=tk.X, padx=40, pady=10)
        
        # Custom styled progress bar
        style = ttk.Style()
        style.theme_use('clam')
        style.configure("Custom.Horizontal.TProgressbar",
                       troughcolor='#3e3e42',
                       bordercolor=bg_color,
                       background=accent,
                       lightcolor=accent,
                       darkcolor=accent,
                       thickness=8)
        
        self.progress = ttk.Progressbar(progress_container,
                                       style="Custom.Horizontal.TProgressbar",
                                       mode='indeterminate',
                                       length=370)
        self.progress.pack()
        self.progress.start(10)
        
        # Prevent closing
        self.window.protocol("WM_DELETE_WINDOW", lambda: None)
        
    def update_status(self, text):
        """Update the status message"""
        self.status_label.config(text=text)
        self.window.update()
        
    def close(self):
        """Close the progress dialog"""
        self.progress.stop()
        self.window.grab_release()
        self.window.destroy()

class WebIDE:
    def __init__(self, root):
        self.root = root
        self.root.title("Web IDE - Professional Editor with AI")

        # Load config first
        self.config = load_config()
        
        # Initialize data from config
        self.pages = self.config.get('pages', {})
        self.export_folder = self.config.get('export_folder', '')
        
        # If no pages in config, create a default one
        if not self.pages:
            self.pages = {
                "index.html": "<!DOCTYPE html>\n<html>\n<head>\n    <title>My Website</title>\n</head>\n<body>\n    <h1>Welcome to My Website</h1>\n    <p>Start editing your content here.</p>\n</body>\n</html>"
            }
            self._save_pages_to_config()

        # Window sizing
        screen_width = root.winfo_screenwidth()
        screen_height = root.winfo_screenheight()
        window_width = int(screen_width * 0.9)
        window_height = int(screen_height * 0.85)
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        self.root.geometry(f"{window_width}x{window_height}+{x}+{y}")

        # Data storage
        self.current_page = None
        self.preview_window = None
        self.unsaved_changes = False

        # Theme
        self.bg_dark = "#1e1e1e"
        self.bg_medium = "#252526"
        self.bg_light = "#2d2d30"
        self.accent = "#007acc"
        self.accent_hover = "#1e8ad6"
        self.text_color = "#d4d4d4"
        self.border_color = "#3e3e42"

        self.root.configure(bg=self.bg_dark)
        self.setup_styles()
        self.create_ui()
        
        # Load the first page automatically
        if self.pages:
            self._populate_page_list()
            self.page_listbox.selection_set(0)
            self.load_page()

    def _save_pages_to_config(self):
        """Save pages to config and persist immediately"""
        self.config['pages'] = self.pages
        self.config['export_folder'] = self.export_folder
        save_config(self.config)

    def _auto_save(self):
        """Auto-save current page and config"""
        if self.current_page and self.code_text:
            current_content = self.code_text.get("1.0", tk.END)
            self.pages[self.current_page] = current_content
            self._save_pages_to_config()

    def _populate_page_list(self):
        """Populate the page listbox with all pages"""
        self.page_listbox.delete(0, tk.END)
        for page_name in self.pages.keys():
            self.page_listbox.insert(tk.END, page_name)

    def setup_styles(self):
        style = ttk.Style()
        style.theme_use('clam')
        style.configure("Treeview",
                        background=self.bg_medium,
                        foreground=self.text_color,
                        fieldbackground=self.bg_medium,
                        borderwidth=0)
        style.map('Treeview', background=[('selected', self.accent)])
        style.configure("Accent.TButton",
                        background=self.accent,
                        foreground="white",
                        borderwidth=0,
                        focuscolor='none',
                        padding=10)
        style.map("Accent.TButton",
                  background=[('active', self.accent_hover)])

    def create_ui(self):
        main_container = tk.Frame(self.root, bg=self.bg_dark)
        main_container.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)

        # Left panel
        left_panel = tk.Frame(main_container, bg=self.bg_medium, width=300)
        left_panel.pack(side=tk.LEFT, fill=tk.BOTH, padx=(0, 1))
        left_panel.pack_propagate(False)

        header_frame = tk.Frame(left_panel, bg=self.bg_light, height=60)
        header_frame.pack(fill=tk.X, pady=(0, 2))
        header_frame.pack_propagate(False)

        title_label = tk.Label(header_frame, text="üìÑ Pages",
                               font=("Segoe UI", 14, "bold"),
                               bg=self.bg_light, fg=self.text_color)
        title_label.pack(pady=15, padx=20, anchor=tk.W)

        add_btn_frame = tk.Frame(left_panel, bg=self.bg_medium)
        add_btn_frame.pack(fill=tk.X, padx=15, pady=10)

        add_btn = tk.Button(add_btn_frame, text="+ New Page",
                            font=("Segoe UI", 10, "bold"),
                            bg=self.accent, fg="white",
                            activebackground=self.accent_hover,
                            activeforeground="white",
                            relief=tk.FLAT, cursor="hand2",
                            command=self.add_page)
        add_btn.pack(fill=tk.X, ipady=8)

        list_frame = tk.Frame(left_panel, bg=self.bg_medium)
        list_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=(0, 15))

        scrollbar = tk.Scrollbar(list_frame, bg=self.bg_medium)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        self.page_listbox = tk.Listbox(list_frame,
                                       bg=self.bg_medium,
                                       fg=self.text_color,
                                       selectbackground=self.accent,
                                       selectforeground="white",
                                       font=("Segoe UI", 11),
                                       relief=tk.FLAT,
                                       highlightthickness=0,
                                       yscrollcommand=scrollbar.set,
                                       activestyle='none')
        self.page_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.config(command=self.page_listbox.yview)
        self.page_listbox.bind('<<ListboxSelect>>', self.load_page)
        self.page_listbox.bind('<Double-Button-1>', self.rename_page)

        rename_btn = tk.Button(left_panel, text="‚úèÔ∏è Rename Page",
                               font=("Segoe UI", 10),
                               bg="#495057", fg="white",
                               activebackground="#6c757d",
                               activeforeground="white",
                               relief=tk.FLAT, cursor="hand2",
                               command=self.rename_page)
        rename_btn.pack(fill=tk.X, padx=15, pady=(0, 10), ipady=6)

        delete_btn = tk.Button(left_panel, text="üóëÔ∏è Delete Page",
                               font=("Segoe UI", 10),
                               bg="#c92a2a", fg="white",
                               activebackground="#e03131",
                               activeforeground="white",
                               relief=tk.FLAT, cursor="hand2",
                               command=self.delete_page)
        delete_btn.pack(fill=tk.X, padx=15, pady=(0, 10), ipady=6)

        clear_btn = tk.Button(left_panel, text="üîÑ Reset Page",
                              font=("Segoe UI", 10),
                              bg="#f59f00", fg="white",
                              activebackground="#fd7e14",
                              activeforeground="white",
                              relief=tk.FLAT, cursor="hand2",
                              command=self.reset_page)
        clear_btn.pack(fill=tk.X, padx=15, pady=(0, 15), ipady=6)

        # Right panel
        right_panel = tk.Frame(main_container, bg=self.bg_dark)
        right_panel.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)

        top_bar = tk.Frame(right_panel, bg=self.bg_light, height=60)
        top_bar.pack(fill=tk.X, pady=(0, 2))
        top_bar.pack_propagate(False)

        page_title = tk.Label(top_bar, text="‚ú® Code Editor",
                              font=("Segoe UI", 14, "bold"),
                              bg=self.bg_light, fg=self.text_color)
        page_title.pack(side=tk.LEFT, pady=15, padx=20)

        # Buttons on top bar
        api_key_btn = tk.Button(top_bar, text="üîë API Key",
                               font=("Segoe UI", 10, "bold"),
                               bg="#6c757d", fg="white",
                               activebackground="#5a6268",
                               activeforeground="white",
                               relief=tk.FLAT, cursor="hand2",
                               command=self.set_api_key)
        api_key_btn.pack(side=tk.RIGHT, padx=(0, 10), ipadx=15, ipady=8)

        ai_btn = tk.Button(top_bar, text="ü§ñ Ask AI to Edit",
                           font=("Segoe UI", 10, "bold"),
                           bg="#8e44ad", fg="white",
                           activebackground="#9b59b6",
                           activeforeground="white",
                           relief=tk.FLAT, cursor="hand2",
                           command=self.ask_ai_to_edit)
        ai_btn.pack(side=tk.RIGHT, padx=(0, 10), ipadx=15, ipady=8)

        open_folder_btn = tk.Button(top_bar, text="üìÅ Open Folder",
                                    font=("Segoe UI", 10, "bold"),
                                    bg="#6c757d", fg="white",
                                    activebackground="#5a6268",
                                    activeforeground="white",
                                    relief=tk.FLAT, cursor="hand2",
                                    command=self.open_export_folder)
        open_folder_btn.pack(side=tk.RIGHT, padx=(0, 20), ipadx=15, ipady=8)

        export_btn = tk.Button(top_bar, text="üì¶ Export All",
                               font=("Segoe UI", 10, "bold"),
                               bg="#17a2b8", fg="white",
                               activebackground="#138496",
                               activeforeground="white",
                               relief=tk.FLAT, cursor="hand2",
                               command=self.export_all_pages)
        export_btn.pack(side=tk.RIGHT, padx=(0, 10), ipadx=15, ipady=8)

        preview_btn = tk.Button(top_bar, text="üëÅÔ∏è Preview",
                                font=("Segoe UI", 10, "bold"),
                                bg="#28a745", fg="white",
                                activebackground="#34ce57",
                                activeforeground="white",
                                relief=tk.FLAT, cursor="hand2",
                                command=self.preview_page)
        preview_btn.pack(side=tk.RIGHT, padx=(0, 10), ipadx=20, ipady=8)

        save_btn = tk.Button(top_bar, text="üíæ Save",
                             font=("Segoe UI", 10, "bold"),
                             bg=self.accent, fg="white",
                             activebackground=self.accent_hover,
                             activeforeground="white",
                             relief=tk.FLAT, cursor="hand2",
                             command=self.save_current_page)
        save_btn.pack(side=tk.RIGHT, padx=(0, 10), ipadx=20, ipady=8)

        # Code editor
        editor_frame = tk.Frame(right_panel, bg=self.bg_medium)
        editor_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=(0, 15))

        line_frame = tk.Frame(editor_frame, bg=self.bg_light, width=50)
        line_frame.pack(side=tk.LEFT, fill=tk.Y)

        self.line_numbers = tk.Text(line_frame,
                                    width=4,
                                    padx=5,
                                    pady=10,
                                    bg=self.bg_light,
                                    fg="#858585",
                                    font=("Consolas", 11),
                                    state=tk.DISABLED,
                                    relief=tk.FLAT)
        self.line_numbers.pack(fill=tk.BOTH, expand=True)

        text_frame = tk.Frame(editor_frame, bg=self.bg_medium)
        text_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        scrollbar_y = tk.Scrollbar(text_frame)
        scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y)

        scrollbar_x = tk.Scrollbar(text_frame, orient=tk.HORIZONTAL)
        scrollbar_x.pack(side=tk.BOTTOM, fill=tk.X)

        self.code_text = tk.Text(text_frame,
                                 font=("Consolas", 11),
                                 bg=self.bg_medium,
                                 fg=self.text_color,
                                 insertbackground=self.text_color,
                                 selectbackground=self.accent,
                                 selectforeground="white",
                                 relief=tk.FLAT,
                                 padx=10,
                                 pady=10,
                                 wrap=tk.NONE,
                                 undo=True,
                                 yscrollcommand=scrollbar_y.set,
                                 xscrollcommand=scrollbar_x.set)
        self.code_text.pack(fill=tk.BOTH, expand=True)

        scrollbar_y.config(command=self.code_text.yview)
        scrollbar_x.config(command=self.code_text.xview)

        self.code_text.bind('<KeyRelease>', self.on_code_change)
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)

        status_bar = tk.Frame(right_panel, bg=self.bg_light, height=30)
        status_bar.pack(fill=tk.X)
        status_bar.pack_propagate(False)
        self.status_label = tk.Label(status_bar, text="Ready - All changes auto-save",
                                     font=("Segoe UI", 9),
                                     bg=self.bg_light, fg=self.text_color,
                                     anchor=tk.W)
        self.status_label.pack(side=tk.LEFT, padx=20)
        self.update_line_numbers()

    # ---------------------------------------------------------
    # üîë API KEY MANAGEMENT
    # ---------------------------------------------------------
    def set_api_key(self):
        """Prompt user to set OpenAI API key"""
        current_key = self.config.get('api_key', '')
        masked_key = f"{current_key[:8]}...{current_key[-4:]}" if current_key else "Not set"
        
        dialog = tk.Toplevel(self.root)
        dialog.title("Set OpenAI API Key")
        dialog.geometry("500x200")
        dialog.configure(bg=self.bg_medium)
        dialog.transient(self.root)
        dialog.grab_set()
        
        # Center window
        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() // 2) - (500 // 2)
        y = (dialog.winfo_screenheight() // 2) - (200 // 2)
        dialog.geometry(f"+{x}+{y}")
        
        tk.Label(dialog, text=f"Current API Key: {masked_key}",
                bg=self.bg_medium, fg=self.text_color,
                font=("Segoe UI", 9)).pack(pady=(15, 5))
        
        tk.Label(dialog, text="Enter your OpenAI API Key:",
                bg=self.bg_medium, fg=self.text_color,
                font=("Segoe UI", 11, "bold")).pack(pady=(5, 5))
        
        key_entry = tk.Entry(dialog, width=50, font=("Consolas", 10),
                            bg=self.bg_light, fg=self.text_color,
                            insertbackground=self.text_color,
                            relief=tk.FLAT)
        key_entry.pack(pady=10, padx=20)
        key_entry.focus()
        
        if current_key:
            key_entry.insert(0, current_key)
        
        def save_key():
            key = key_entry.get().strip()
            if key:
                self.config['api_key'] = key
                save_config(self.config)
                messagebox.showinfo("Success", "API key saved successfully!")
                dialog.destroy()
            else:
                messagebox.showwarning("Warning", "Please enter a valid API key.")
        
        btn_frame = tk.Frame(dialog, bg=self.bg_medium)
        btn_frame.pack(pady=15)
        
        tk.Button(btn_frame, text="Save Key",
                 command=save_key,
                 bg=self.accent, fg="white",
                 relief=tk.FLAT, cursor="hand2",
                 font=("Segoe UI", 10, "bold"),
                 padx=20, pady=8).pack(side=tk.LEFT, padx=5)
        
        tk.Button(btn_frame, text="Cancel",
                 command=dialog.destroy,
                 bg="#6c757d", fg="white",
                 relief=tk.FLAT, cursor="hand2",
                 font=("Segoe UI", 10),
                 padx=20, pady=8).pack(side=tk.LEFT, padx=5)

    def get_api_key(self):
        """Get API key from config or prompt user"""
        api_key = self.config.get('api_key', '')
        if not api_key:
            messagebox.showinfo("API Key Required", 
                              "Please set your OpenAI API key first.\nClick the 'üîë API Key' button.")
            self.set_api_key()
            api_key = self.config.get('api_key', '')
        return api_key

    # ---------------------------------------------------------
    # üìÑ PAGE MANAGEMENT
    # ---------------------------------------------------------
    def add_page(self):
        """Add a new page with custom name"""
        name = simpledialog.askstring("New Page", 
                                     "Enter page name (without .html):",
                                     parent=self.root)
        if not name:
            return
        
        # Add .html extension if not present
        if not name.endswith('.html'):
            name += '.html'
        
        # Check if name already exists
        if name in self.pages:
            messagebox.showerror("Error", f"Page '{name}' already exists!")
            return
        
        self.pages[name] = "<!DOCTYPE html>\n<html>\n<head>\n    <title>New Page</title>\n</head>\n<body>\n    <h1>New Page</h1>\n</body>\n</html>"
        self.page_listbox.insert(tk.END, name)
        self.page_listbox.selection_clear(0, tk.END)
        self.page_listbox.selection_set(tk.END)
        self.load_page()
        self._auto_save()
        self.status_label.config(text=f"‚úÖ Created & saved: {name}")

    def rename_page(self, event=None):
        """Rename the selected page"""
        sel = self.page_listbox.curselection()
        if not sel:
            messagebox.showinfo("Info", "Please select a page to rename.")
            return
        
        old_name = self.page_listbox.get(sel[0])
        new_name = simpledialog.askstring("Rename Page", 
                                         "Enter new page name:",
                                         initialvalue=old_name.replace('.html', ''),
                                         parent=self.root)
        if not new_name or new_name == old_name.replace('.html', ''):
            return
        
        # Add .html extension if not present
        if not new_name.endswith('.html'):
            new_name += '.html'
        
        # Check if new name already exists
        if new_name in self.pages and new_name != old_name:
            messagebox.showerror("Error", f"Page '{new_name}' already exists!")
            return
        
        # Rename the page
        self.pages[new_name] = self.pages.pop(old_name)
        self.page_listbox.delete(sel[0])
        self.page_listbox.insert(sel[0], new_name)
        self.page_listbox.selection_set(sel[0])
        
        if self.current_page == old_name:
            self.current_page = new_name
        
        self._auto_save()
        self.status_label.config(text=f"‚úÖ Renamed & saved: {old_name} ‚Üí {new_name}")

    def delete_page(self):
        sel = self.page_listbox.curselection()
        if not sel:
            return
        name = self.page_listbox.get(sel[0])
        if messagebox.askyesno("Confirm", f"Delete {name}?"):
            del self.pages[name]
            self.page_listbox.delete(sel[0])
            self.code_text.delete("1.0", tk.END)
            self.current_page = None
            self._auto_save()
            self.status_label.config(text=f"‚úÖ Deleted: {name}")

    def reset_page(self):
        if not self.current_page:
            return
        if messagebox.askyesno("Confirm", "Reset to blank?"):
            self.pages[self.current_page] = "<!DOCTYPE html>\n<html>\n<head>\n    <title>Blank Page</title>\n</head>\n<body>\n    <h1>Blank Page</h1>\n</body>\n</html>"
            self.code_text.delete("1.0", tk.END)
            self.code_text.insert("1.0", self.pages[self.current_page])
            self._auto_save()
            self.status_label.config(text="‚úÖ Reset & saved")

    def load_page(self, event=None):
        sel = self.page_listbox.curselection()
        if not sel:
            return
        if self.current_page and self.code_text:
            # Save current page before switching
            self.pages[self.current_page] = self.code_text.get("1.0", tk.END)
        name = self.page_listbox.get(sel[0])
        self.current_page = name
        self.code_text.delete("1.0", tk.END)
        self.code_text.insert("1.0", self.pages[name])
        self.update_line_numbers()
        self.status_label.config(text=f"üìÅ Loaded: {name}")

    def save_current_page(self):
        if not self.current_page:
            return
        self.pages[self.current_page] = self.code_text.get("1.0", tk.END)
        self._auto_save()
        self.status_label.config(text=f"‚úÖ Saved: {self.current_page}")

    def preview_page(self):
        if not self.current_page:
            return
        self.save_current_page()
        temp = tempfile.NamedTemporaryFile(mode="w", suffix=".html", delete=False, encoding="utf-8")
        temp.write(self.pages[self.current_page])
        temp.close()

        file_url = Path(temp.name).resolve().as_uri()
        webbrowser.open(file_url)
        self.status_label.config(text=f"üëÅÔ∏è Previewing: {self.current_page}")

    def export_all_pages(self):
        if not self.pages:
            messagebox.showinfo("Info", "No pages to export!")
            return
        folder = filedialog.askdirectory(title="Choose Export Folder")
        if not folder:
            return
        for name, content in self.pages.items():
            path = os.path.join(folder, name)
            with open(path, 'w', encoding='utf-8') as f:
                f.write(content)
        self.export_folder = folder
        self._auto_save()
        messagebox.showinfo("Success", f"‚úÖ Exported {len(self.pages)} pages to:\n{folder}")

    def open_export_folder(self):
        if self.export_folder and os.path.exists(self.export_folder):
            webbrowser.open(self.export_folder)
        else:
            messagebox.showinfo("Info", "No export folder found. Export pages first.")

    # ---------------------------------------------------------
    # ü§ñ AI FUNCTIONS (Optimized for speed and reliability)
    # ---------------------------------------------------------
    def ask_ai_to_edit(self):
        if not self.current_page:
            messagebox.showinfo("Info", "No page selected!")
            return

        # Check for API key
        api_key = self.get_api_key()
        if not api_key:
            return

        prompt_window = tk.Toplevel(self.root)
        prompt_window.title("Ask AI to Edit Page")
        prompt_window.geometry("500x250")
        prompt_window.configure(bg=self.bg_medium)
        prompt_window.transient(self.root)
        prompt_window.grab_set()

        # Center the window
        prompt_window.update_idletasks()
        x = (prompt_window.winfo_screenwidth() // 2) - (500 // 2)
        y = (prompt_window.winfo_screenheight() // 2) - (250 // 2)
        prompt_window.geometry(f"+{x}+{y}")

        tk.Label(prompt_window, text="Describe what you want to change (be specific for faster results):",
                 bg=self.bg_medium, fg=self.text_color,
                 font=("Segoe UI", 11, "bold")).pack(pady=(15, 5))

        prompt_text = tk.Text(prompt_window, height=6, wrap=tk.WORD,
                              font=("Segoe UI", 10),
                              bg=self.bg_light, fg=self.text_color,
                              insertbackground=self.text_color,
                              relief=tk.FLAT, padx=10, pady=10)
        prompt_text.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        prompt_text.focus()

        def send_request():
            user_request = prompt_text.get("1.0", tk.END).strip()
            if not user_request:
                messagebox.showwarning("Warning", "Please describe the change.")
                return
            prompt_window.destroy()
            self._send_to_ai_threaded(user_request)

        tk.Button(prompt_window, text="Send to AI",
                  command=send_request,
                  bg=self.accent, fg="white",
                  relief=tk.FLAT, cursor="hand2",
                  font=("Segoe UI", 10, "bold"),
                  padx=20, pady=8).pack(pady=10)

    def _send_to_ai_threaded(self, user_request):
        """Run AI request in background thread with progress dialog"""
        api_key = self.get_api_key()
        if not api_key:
            return

        # Check input size
        html_code = self.code_text.get("1.0", tk.END)
        html_length = len(html_code)
        # Allow larger files but warn if size may cause timeouts
        if html_length > 60000:
            messagebox.showwarning(
                "Warning",
                "HTML content is extremely large and may timeout."
                " Try simplifying the page before asking the AI to edit."
            )
            return
        if html_length > 20000:
            proceed = messagebox.askyesno(
                "Large HTML Detected",
                "The HTML content is quite large and may take longer to process.\n"
                "Do you still want to continue?"
            )
            if not proceed:
                return

        # Create progress dialog
        progress = ProgressDialog(self.root, "AI Processing")
        
        # Container for result
        result = {"html": None, "error": None, "timeout": False}
        
        def ai_worker():
            """Background thread for AI request"""
            try:
                start_time = time.time()
                
                # Update status
                self.root.after(0, lambda: progress.update_status("Connecting to OpenAI..."))
                
                client = OpenAI(api_key=api_key)

                # Configure a per-request timeout without relying on unsupported kwargs
                try:
                    chat_with_timeout = client.chat.completions.with_options(timeout=45)
                except AttributeError:
                    # Older SDKs may not support with_options; fall back gracefully
                    chat_with_timeout = client.chat.completions

                self.root.after(0, lambda: progress.update_status("Sending request..."))

                # Optimized prompt
                prompt = f"""Return ONLY the complete HTML code, no explanations or markdown.
Current HTML:
{html_code}

Request: {user_request}

Return the full updated HTML code, keeping changes minimal and efficient:"""
                
                # Retry logic
                max_retries = 2
                for attempt in range(max_retries):
                    try:
                        response = chat_with_timeout.create(
                            model="gpt-4o-mini",
                            messages=[{"role": "user", "content": prompt}],
                            temperature=0.5,  # Lower for focused output
                            max_tokens=1200  # Reduced for faster response
                        )
                        break  # Success, exit retry loop
                    except Exception as e:
                        if "timeout" in str(e).lower():
                            if attempt < max_retries - 1:
                                self.root.after(0, lambda: progress.update_status(f"Retrying... (Attempt {attempt + 2})"))
                                time.sleep(2)  # Brief delay before retry
                                continue
                            result["timeout"] = True
                        else:
                            raise e
                        return
                
                processing_time = time.time() - start_time
                print(f"AI request completed in {processing_time:.2f} seconds")
                
                new_html = response.choices[0].message.content.strip()
                
                # Simplified response cleanup
                if new_html.startswith("```html") or new_html.startswith("```"):
                    new_html = new_html[new_html.index('\n') + 1:] if '\n' in new_html else new_html[3:]
                if new_html.endswith("```"):
                    new_html = new_html[:-3]
                new_html = new_html.strip()
                
                result["html"] = new_html
                
            except Exception as e:
                error_msg = str(e).lower()
                if "rate limit" in error_msg:
                    result["error"] = "API rate limit exceeded. Please wait and try again."
                elif "invalid api key" in error_msg:
                    result["error"] = "Invalid API key. Please check your API key."
                else:
                    result["error"] = f"Error: {str(e)}"
            finally:
                # Close progress dialog and show result
                self.root.after(0, lambda: self._handle_ai_result(progress, result))
        
        # Start background thread
        thread = threading.Thread(target=ai_worker, daemon=True)
        thread.start()

    def _handle_ai_result(self, progress, result):
        """Handle AI result on main thread"""
        progress.close()
        
        if result["timeout"]:
            messagebox.showerror("Timeout", "AI request took too long. Try a simpler request or check your connection.")
            self.status_label.config(text="‚ùå AI request timed out")
            return
            
        if result["error"]:
            messagebox.showerror("AI Error", f"Request failed:\n{result['error']}")
            self.status_label.config(text="‚ùå AI request failed")
            return
        
        if result["html"]:
            # Auto-apply changes and save
            self.code_text.delete("1.0", tk.END)
            self.code_text.insert("1.0", result["html"])
            self.update_line_numbers()
            self.unsaved_changes = True
            self._auto_save()  # Auto-save the AI changes
            self.status_label.config(text="‚úÖ AI changes applied & saved!")

    def on_code_change(self, event=None):
        self.update_line_numbers()
        self.unsaved_changes = True
        # Auto-save after a short delay (so it doesn't save on every keystroke)
        if hasattr(self, '_auto_save_job'):
            self.root.after_cancel(self._auto_save_job)
        self._auto_save_job = self.root.after(2000, self._auto_save)  # Save after 2 seconds of inactivity

    def update_line_numbers(self, event=None):
        lines = int(self.code_text.index('end-1c').split('.')[0])
        self.line_numbers.config(state=tk.NORMAL)
        self.line_numbers.delete('1.0', tk.END)
        self.line_numbers.insert('1.0', '\n'.join(str(i) for i in range(1, lines + 1)))
        self.line_numbers.config(state=tk.DISABLED)

    def on_closing(self):
        """Save everything before closing"""
        self._auto_save()
        if messagebox.askokcancel("Quit", "Do you want to quit? All changes have been saved."):
            self.root.destroy()

def main():
    root = tk.Tk()
    app = WebIDE(root)
    root.mainloop()

if __name__ == "__main__":
    main()
